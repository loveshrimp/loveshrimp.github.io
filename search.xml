<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>英语积累</title>
      <link href="/2099/09/09/ENmovies/"/>
      <url>/2099/09/09/ENmovies/</url>
      
        <content type="html"><![CDATA[<p>最近为了准备四六级考试，去youtube和TED上看了看，发现了一些很有趣的频道，听着也不是很难，而且对我也很有帮助。感觉还蛮有意思的，以后决定常常学习这些视频，每看完一个视频都用思维导图的形式做总结。<br><a id="more"></a></p><h2 id="1-How-to-become-a-better-reader"><a href="#1-How-to-become-a-better-reader" class="headerlink" title="1.How to become a better reader"></a>1.How to become a better reader</h2><p>一直觉得自己不会看书，特别是专业课的书，常常看着看着就出了神。也常常抓不住书中的重点。想想看很大一部分原因是自己小时候读书太少了，也很少静下心来投入的去钻研过某些书籍。从这个视频中我学到了很多：看书时笔不离手，有问题或者不懂得东西先标记等看完有了大体印象后再返回来查，讲重点内容讲给自己听以加深印象和理解…..The movie really helps a lot,hope me happy reading~<br><img src="1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 积累 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python数学处理相关库</title>
      <link href="/2019/05/13/python%E7%9B%B8%E5%85%B3%E5%BA%93/"/>
      <url>/2019/05/13/python%E7%9B%B8%E5%85%B3%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>整理了机器学习中常用的数学处理的库，numpy，matplot等的相关函数的用法。<br><a id="more"></a></p><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><h3 id="Ndarray对象"><a href="#Ndarray对象" class="headerlink" title="Ndarray对象"></a>Ndarray对象</h3>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
            <tag> matplot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法复习</title>
      <link href="/2018/12/11/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2018/12/11/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>整理大三上的算法导论。<br><a id="more"></a></p><h1 id="chapter9-动态规划"><a href="#chapter9-动态规划" class="headerlink" title="chapter9-动态规划"></a>chapter9-动态规划</h1><h2 id="解决什么样的问题？"><a href="#解决什么样的问题？" class="headerlink" title="解决什么样的问题？"></a>解决什么样的问题？</h2><p>动态规划(Dynamic Programming)与分治法都是通过组合子问题的解来求解原问题。常常用来解决最优解问题。<br><strong>分治法</strong>：互不相交的子问题，递归地求解子问题。如果<strong>子问题有重叠</strong>，则递归求解中就会反复地求解这些公共子问题，造成算法效率的下降。 </p><p><strong>动态规划</strong>：有子问题重叠的情况，即不同的子问题具有公共的子子问题。动态规划算法对每个这样的子子问题只求解一次，将其<strong>解保存在一个表格中</strong>，再次碰到时，无需重新计算，只从表中找到上次计算的结果加以引用即可。</p><h2 id="动态规划的一般步骤"><a href="#动态规划的一般步骤" class="headerlink" title="动态规划的一般步骤"></a>动态规划的一般步骤</h2><ol><li>刻画一个最优解的结构特征；</li><li>递归地定义最优解的值；</li><li>计算最优解的值；</li><li>利用计算出的信息，构造一个最优解。</li></ol><p>步骤4常常根据实际情况而定，为了构造最优解的值，常常需要在前三步的基础上保存一些额外的信息。</p><p><strong>最优子结构</strong>：<br>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。可以用反证法（剪切粘贴法）来证明问题的最优子结构性。</p><h2 id="动态规划的两种常用方法"><a href="#动态规划的两种常用方法" class="headerlink" title="动态规划的两种常用方法"></a>动态规划的两种常用方法</h2><ul><li>自顶向下的备忘录法</li><li>自底向上（常用）<br>一纲条切割为例(问题描述见下文)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自顶向下备忘录法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxvalue</span><span class="params">(<span class="keyword">int</span> cur_length, <span class="keyword">int</span> left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[left] || left == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        value1 = a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = maxvalue(<span class="number">1</span>, left - <span class="number">1</span>);</span><br><span class="line">        a[left] = value1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = value[cur_length] + value1;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_temp = maxvalue(cur_length + <span class="number">1</span>, left - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; cur_temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cur_temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自底向上法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxvalue</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = value[j] + a[i];</span><br><span class="line">            <span class="keyword">if</span> (p &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                p = temp;</span><br><span class="line">                root[i] = j;<span class="comment">//每次记忆当前取的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动态规划例子"><a href="#动态规划例子" class="headerlink" title="动态规划例子"></a>动态规划例子</h2><h3 id="15-1钢条切割"><a href="#15-1钢条切割" class="headerlink" title="15.1钢条切割"></a>15.1钢条切割</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><img src="15-1.png" alt=""><br><img src="15-2.png" alt=""></p><h4 id="问题划分"><a href="#问题划分" class="headerlink" title="问题划分"></a>问题划分</h4><p>对于长度为n（n≥1）的钢条，设rn是最优切割的收益<br>对最优切割，若其<strong>首次切割</strong>在位置i，钢条被分成长度为i和n-i的两段，有：<br>$r_n= r_i+ r_{n-i}$<br>一般情况，任意切割点j都将钢条分为两段，长度分别为j和n-j，1≤j≤n。令$r_j$和$r_{n-j}$分别是<strong>这两段的最优切割收益</strong>，则该切割可获得的最好收益是：$r_n= r_j+ r_{n-j}$<br>所以有：<br><img src="15-3.png" alt=""></p><h4 id="解的构建"><a href="#解的构建" class="headerlink" title="解的构建"></a>解的构建</h4><p>用一个数组s用于记录对规模为j的钢条切割出的第一段钢条的长度s[j]。</p><h3 id="15-2矩阵链乘法"><a href="#15-2矩阵链乘法" class="headerlink" title="15.2矩阵链乘法"></a>15.2矩阵链乘法</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定n个矩阵的链&lt;A1,A2,…,An&gt;，其中i=1,2,…,n，矩阵Ai的维数为pi-1×pi。求一个完全“括号化方案”，使得计算乘积A1A2…An所需的标量乘法次数最小。</p><h4 id="问题划分-1"><a href="#问题划分-1" class="headerlink" title="问题划分"></a>问题划分</h4><p><img src="15-4.png" alt=""></p><h4 id="解的构建-1"><a href="#解的构建-1" class="headerlink" title="解的构建"></a>解的构建</h4><p>由m表和s表构建<br>S[i,j]记录了AiAi+1…Aj的最优括号化方案的<strong>最后一个</strong>分割点k</p><h3 id="15-3最大公共子序列"><a href="#15-3最大公共子序列" class="headerlink" title="15.3最大公共子序列"></a>15.3最大公共子序列</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>子序列，公共子序列，最长公共子序列的描述自查。</p><h4 id="问题划分-2"><a href="#问题划分-2" class="headerlink" title="问题划分"></a>问题划分</h4><p>设有序列X=&lt;$x_1,x_2,…,x_m$&gt;和$$Y=&lt;y_1,y_2,…,y_n&gt;$，并<br>设序列Z=&lt;$z_1,z_2,…,z_k$&gt;为X和Y的任意一个LCS。<br>  （1）若$x_m=y_n$，则$zk=xm=yn$，且$Zk-1$是$Xm-1$和$Yn-1$的一个LCS。<br>  （2）若xm≠yn，则zk≠xm蕴含Z是Xm-1和Y的一个LCS。<br>  （3）若xm≠yn，则zk≠yn蕴含Z是X和Yn-1的一个LCS。<br><img src="15-5.png" alt=""></p><h4 id="解的构建-2"><a href="#解的构建-2" class="headerlink" title="解的构建"></a>解的构建</h4><p>利用类似下图的表进行构建<br><img src="15-6.png" alt=""></p><h3 id="15-5最优二叉搜索树搜索树"><a href="#15-5最优二叉搜索树搜索树" class="headerlink" title="15.5最优二叉搜索树搜索树"></a>15.5最优二叉搜索树搜索树</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><h4 id="问题划分-3"><a href="#问题划分-3" class="headerlink" title="问题划分"></a>问题划分</h4><h4 id="解的构建-3"><a href="#解的构建-3" class="headerlink" title="解的构建"></a>解的构建</h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习整理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进程控制实验</title>
      <link href="/2018/12/11/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/12/11/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统实验 </tag>
            
            <tag> 进程 </tag>
            
            <tag> fork </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式系统</title>
      <link href="/2018/12/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/12/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本文是为了操作系统的课堂任务而整理的一些资料。<br><a id="more"></a></p><h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><p><strong>说明</strong><br>报告要求时间:5~10分钟。</p><p>介绍时间安排及思路建议：（请点击左侧小标题快速查找内容）</p><p><strong>一.什么是分布式系统</strong>：（3~5分钟）——发展历程,适用范围</p><ol><li>分布式系统发展史</li><li>分布式系统概念</li><li>分布式系统的应用 </li></ol><p><strong>二.分布式系统的特性</strong>：（1~3分钟）——优缺点，对比分析</p><ol><li>列举相关特性，简单介绍。</li><li>和传统系统构架做对比。 </li></ol><p><strong>三.分布式系统的未来</strong>：（1~2分钟，可以根据实际时间情况进行调整）——未来展望</p><ol><li>分析面临的挑战</li><li>分析未来形势<h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><h3 id="分布式系统发展史"><a href="#分布式系统发展史" class="headerlink" title="分布式系统发展史"></a>分布式系统发展史</h3><blockquote><p>首先讲讲发展史。</p></blockquote></li></ol><p>参考网站：</p><p><a href="https://www.infoq.cn/article/the-evolution-of-distributed-systems" target="_blank" rel="noopener">分布式系统发展史</a><br><a href="https://zhuanlan.zhihu.com/p/31392387" target="_blank" rel="noopener">操作系统的发展过程</a></p><h3 id="分布式系统的概念"><a href="#分布式系统的概念" class="headerlink" title="分布式系统的概念"></a>分布式系统的概念</h3><blockquote><p>引出分布式系统的定义，再做简单的介绍</p><ul><li>定义（概念）</li><li>分类</li></ul></blockquote><p>参考网站：<br><a href="http://www.baike.com/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">wiki介绍</a><br><a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/1847932?fromtitle=%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&amp;fromid=2475063" target="_blank" rel="noopener">百度文库定义</a><br><a href="https://www.zhihu.com/question/20004877" target="_blank" rel="noopener">区别一下分布式系统与集群</a><br><a href="https://www.hollischuang.com/archives/655" target="_blank" rel="noopener">初识分布式系统</a><br><a href="http://www.cbdio.com/BigData/2016-03/25/content_4726270.htm" target="_blank" rel="noopener">分布式系统概念及原理介绍</a><br><a href="https://blog.csdn.net/qq_33880788/article/details/79476715" target="_blank" rel="noopener">分布式操作系统简介</a><br><a href="https://blog.csdn.net/caoshuming_500/article/details/51482566" target="_blank" rel="noopener">分布式操作系统概念</a><br><a href="https://www.cnblogs.com/xybaby/p/7787034.html#_label_5" target="_blank" rel="noopener">什么是分布式系统，如何学习分布式系统</a><br><a href="https://waylau.com/talk-about-distributed-system/" target="_blank" rel="noopener">用大白话聊聊分布式系统</a></p><h3 id="分布式系统的应用"><a href="#分布式系统的应用" class="headerlink" title="分布式系统的应用"></a>分布式系统的应用</h3><blockquote><p>举例让大家更通俗的理解分布式系统<br>细讲其中一个例子，再（ppt）展示一些其他的例子 </p></blockquote><p>细讲：<br>大型多人在线游戏（LOL？）</p><p>其他例子：<br><img src="1.png" alt=""><br><a href="http://www.cbdio.com/BigData/2016-03/25/content_4726270.htm" target="_blank" rel="noopener">分布式系统应用介绍</a></p><h2 id="分布式系统的特性"><a href="#分布式系统的特性" class="headerlink" title="分布式系统的特性"></a>分布式系统的特性</h2><h3 id="分布式系统的系统特性"><a href="#分布式系统的系统特性" class="headerlink" title="分布式系统的系统特性"></a>分布式系统的系统特性</h3><blockquote><p>列举一些，简单说明即可</p></blockquote><h3 id="传统架构和分布式系统架构的优缺点"><a href="#传统架构和分布式系统架构的优缺点" class="headerlink" title="传统架构和分布式系统架构的优缺点"></a>传统架构和分布式系统架构的优缺点</h3><blockquote><p>将两者做对比，可以表格或图的形式展示</p></blockquote><p>参考文章<br><a href="https://my.oschina.net/vshcxl/blog/1787977" target="_blank" rel="noopener">传统架构和分布式系统架构的优缺点</a><br><a href="https://blog.csdn.net/zhouhuakang/article/details/50780830" target="_blank" rel="noopener">分布式架构的优缺点</a><br><a href="http://www.west.cn/cms/wiki/server/2017-12-08/4897.html" target="_blank" rel="noopener">什么是分布式操作系统？有哪些优缺点？</a></p><h2 id="分布式系统面临的挑战"><a href="#分布式系统面临的挑战" class="headerlink" title="分布式系统面临的挑战"></a>分布式系统面临的挑战</h2><blockquote><p>分析下当前分布式操作系统发展形势即未来前景。（根据时间决定内容多少）</p></blockquote><p><a href="https://www.huoxing24.com/newsdetail/20180810191638792083.html" target="_blank" rel="noopener">分布式计算现状与未来</a><br><a href="https://wanwang.aliyun.com/info/1555886.html" target="_blank" rel="noopener">分布式文件系统未来</a><br><a href="http://www.chinastor.com/a/jishu/FS/0203200112016.html" target="_blank" rel="noopener">分布式存储的发展演变及未来展望</a></p><h2 id="相关资料链接"><a href="#相关资料链接" class="headerlink" title="相关资料链接"></a>相关资料链接</h2><p><strong>ppt参考</strong><br><a href="http://read.pudn.com/downloads128/ebook/541567/%B5%DA%CA%AE%D5%C2%20-%20%20%B7%D6%B2%BC%CA%BD%B2%D9%D7%F7%CF%B5%CD%B3.ppt" target="_blank" rel="noopener">分布式操作系统ppt下载1</a><br><a href="http://staff.ustc.edu.cn/~dingqing/teach/dos/lecture/DOS-CH1-introduction.ppt" target="_blank" rel="noopener">分布式操作系统ppt下载2</a><br><a href="https://www.slideserve.com/len-horn/7043480" target="_blank" rel="noopener">分布式系统ppt参考</a><br><strong>其他</strong><br><a href="https://github.com/allwefantasy/my-life/blob/master/yarn-operation-system.md" target="_blank" rel="noopener">github相关总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统介绍 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法4：最小时间差(leetcode-539)</title>
      <link href="/2018/12/01/%E7%AE%97%E6%B3%954%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE/"/>
      <url>/2018/12/01/%E7%AE%97%E6%B3%954%EF%BC%9A%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<p>给定一个 24 小时制（小时:分钟）的时间列表，找出列表中任意两个时间的最小时间差并已分钟数表示。这周时间太紧张了（CPU画的还没头绪😭）于是找了道稍微简单的，重在学习他人的思路。<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个 24 小时制（小时:分钟）的时间列表，找出列表中任意两个时间的最小时间差并已分钟数表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出: 1  </span><br><span class="line"></span><br><span class="line">备注:</span><br><span class="line">1.列表中时间数在 2~20000 之间。</span><br><span class="line">2.每个时间取值在 00:00~23:59 之间。</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>一看这道题，思路很明确，将小时制字符串转化为对应分钟数，然后对分钟数进行排序。最后遍历一遍排好的数组，找出最小时间差。对于边界条件，为了求出最后一个时间和第一个时间的时间差，在排序好的数组后边再加一项time[0]+1440(24*60)即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str_to_int</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a )</span></span></span><br><span class="line"><span class="function"><span class="comment">//将小时制字符串转化成分钟数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((a[<span class="number">0</span>] - <span class="string">'0'</span>) * <span class="number">600</span> + (a[<span class="number">1</span>] - <span class="string">'0'</span>) * <span class="number">60</span> + (a[<span class="number">3</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + a[<span class="number">4</span>] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; timePoints)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; cnt(<span class="number">1440</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> str : timePoints)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[str_to_int(str)])<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//找到重复的时间</span></span><br><span class="line"><span class="keyword">else</span> cnt[str_to_int(str)] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; time;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1440</span>; i++) <span class="keyword">if</span> (cnt[i]) time.push_back(i);</span><br><span class="line">time.push_back(time[<span class="number">0</span>] + <span class="number">1440</span>);<span class="comment">//用于计算最迟的时间</span></span><br><span class="line"><span class="keyword">int</span> mindiff = time[<span class="number">1</span>] - time[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time.size()<span class="number">-1</span>; i++) mindiff = min(mindiff, time[i + <span class="number">1</span>] - time[i]);</span><br><span class="line"><span class="keyword">return</span> mindiff;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上代码考虑到了字符串转化成的分钟数最多有1440(24*60)种可能性，因此采用了时间复杂度为O(n)的桶排序(而非nlogn)。值得学习的有vector变量的初始化，以及桶排序的思想,和库函数min()和sort()的使用以及一个C++的小细节（为什么定义成const string &amp; a而非string a）。leetcode提交测试击败了100%的提交。查看相同时间的提交用例发现别人在排序的时候都是用&lt; algorithm &gt;库中的sort()实现，该函数是用快排实现的，实现效率也较高，具体使用方法整理在了另一篇博客中。想想自己以前用到需要比较大小排序的算法都是自己手写，真是笨啊，费时费力效率还不一定高。现在传统的排序算法应该都写过了，以后就直接用现成的了。将精力更多的放在算法实现上面。</p>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++STL部分整理</title>
      <link href="/2018/11/29/C-STL%E9%83%A8%E5%88%86%E6%95%B4%E7%90%86/"/>
      <url>/2018/11/29/C-STL%E9%83%A8%E5%88%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这篇博客用于整理平常经常用到的C++好用的函数（because经常忘记）和一些语法解析。<br><a id="more"></a><br>2018-11-29<br>以前没学过C++，总感觉C++就是在C的基础上多了一点面向对象的东西和多了一些库函数和几个用法。然而最近接触过之后被这门语言折服了。就我学过的高级语言来说，他比C好用太多了，带给人的方便不是一点点，又比python效率高很多，实在让人难以不喜欢。一开始只是觉得C++的库函数很多，而且相较功能相似的C库函数来说封装的更好，让人更方便用。现在在实验中慢慢的体会到了一点面向对象的东西，不得不佩服（有时间在mooc上好好的再学学这种思想）。这篇博客用来整理一些平常经常用到的函数以及一些语法细节。C++是一门很重细节的语言，注重细节才能写出更加强大的程序。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序-sort()"></a>排序-sort()</h3><p>所在库：&lt; algorithm &gt;<br>函数原型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">sort</span> (<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>);</span></span><br><span class="line"><span class="comment">//三参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">sort</span> (<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure></p><p>参数解释：<br>[first,last)<br><a href="https://zh.cppreference.com/w/cpp/named_req/RandomAccessIterator" target="_blank" rel="noopener">RandomAccessIterator</a> first – 排序的数组的起始地址<br><a href="https://zh.cppreference.com/w/cpp/named_req/RandomAccessIterator" target="_blank" rel="noopener">RandomAccessIterator</a> last  – 排序的数组的结束地址<br>Compare comp   – 比较函数<br><a href="http://www.cplusplus.com/reference/algorithm/sort/" target="_blank" rel="noopener">用法示例</a> </p><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><p>所在库&lt; algorithm&gt;<br>min():返回两个元素中的较小者，注意两个元素的的数据类型必须相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; const T&amp; min (const T&amp; a, const T&amp; b);</span><br><span class="line">// 自定义（2）    </span><br><span class="line">template &lt;class T, class Compare&gt;</span><br><span class="line">    const T&amp; min (const T&amp; a, const T&amp; b, Compare comp);</span><br></pre></td></tr></table></figure></p><p>max:返回两个元素中的较大者，注意两个元素的的数据类型必须相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; const T&amp; max (const T&amp; a, const T&amp; b);</span><br><span class="line">// 自定义（2）    </span><br><span class="line">template &lt;class T, class Compare&gt;</span><br><span class="line">    const T&amp; max (const T&amp; a, const T&amp; b, Compare comp);</span><br></pre></td></tr></table></figure></p><p>### </p><h2 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h2><h3 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h3><p>所在库：&lt; string &gt;<br>说明:C++中很好用的字符串类型（注意和C风格的字符串做对比）<br>创建一个字符串：string s;<br> 字符产常用处理函数较多：详情点击<a href="https://www.cnblogs.com/xFreedom/archive/2011/05/16/2048037.html" target="_blank" rel="noopener">这里</a></p><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p><strong>字符转换</strong><br>int toupper(char c)<br>int tolower(char c)<br><strong>string转换</strong><br>利用transform函数<br>transform(str.begin(),str.end(),str.begin(),::tolower);<br>transform(str.begin(),str.end(),str.begin(),::toupper);</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h3><p>所在库：&lt; stack &gt;<br>说明：后进先出的数据结构<br>创建一个栈：stack&lt; element_type &gt; s;<br>常用成员函数：</p><ul><li><strong>s.empty()</strong>：判断一个栈是否为空，是返回true </li><li><strong>s.size()</strong>：返回栈中元素个数 </li><li><strong>s.pop()</strong>：出栈，即删除栈顶元素(注意：只是删除，不返回栈顶元素)</li><li><strong>s.push(x)</strong>：元素x入栈</li><li><strong>s.top</strong>()：返回栈顶元素<h3 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h3>所在库：&lt; queue &gt;<br>说明：先进先出的数据结构<br>创建一个队列:queue&lt; element_type &gt; q;<br>常用成员函数:</li><li><strong>q.push(x)</strong>：将x入队</li><li><strong>q.pop()</strong>：弹出队列的第一个元素（注意：不返回该元素）</li><li><strong>q.size()</strong>：访问队列的元素个数</li><li><strong>q.front()</strong>：返回队首元素</li><li><strong>q.back()</strong>：返回队尾元素<h3 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h3>所在库：&lt; list &gt;<br>说明:list将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢<br>创建一个列表：list&lt; element_type &gt; l;<br>常用成员函数：</li><li><strong>assign()</strong>： 给list赋值 </li><li><strong>back()</strong>： 返回最后一个元素 </li><li><strong>begin()</strong>: 返回指向第一个元素的迭代器 </li><li><strong>clear()</strong>: 删除所有元素 </li><li><strong>empty()</strong>: 如果list是空的则返回true </li><li><strong>end()</strong>: 返回末尾的迭代器 </li><li><strong>erase()</strong>: 删除一个元素 </li><li><strong>front()</strong>: 返回第一个元素 </li><li><strong>get_allocator()</strong>： 返回list的配置器 </li><li><strong>insert()</strong>： 插入一个元素到list中 </li><li><strong>max_size()</strong>： 返回list能容纳的最大元素数量 </li><li><strong>merge()</strong>： 合并两个list </li><li><strong>pop_back()</strong>： 删除最后一个元素 </li><li><strong>pop_front()</strong> 删除第一个元素 </li><li><strong>push_back()</strong> 在list的末尾添加一个元素 </li><li><strong>push_front()</strong> 在list的头部添加一个元素 </li><li><strong>rbegin()</strong> 返回指向第一个元素的逆向迭代器 </li><li><strong>remove()</strong> 从list删除元素 </li><li><strong>remove_if()</strong> 按指定条件删除元素 </li><li><strong>rend()</strong> 指向list末尾的逆向迭代器 </li><li><strong>resize()</strong> 改变list的大小 </li><li><strong>reverse()</strong> 把list的元素倒转 </li><li><strong>size()</strong> 返回list中的元素个数 </li><li><strong>sort()</strong> 给list排序 </li><li><strong>splice()</strong> 合并两个list </li><li><strong>swap()</strong> 交换两个list </li></ul><ul><li><strong>unique()</strong> 删除list中重复的元素<h3 id="向量vector"><a href="#向量vector" class="headerlink" title="向量vector"></a>向量vector</h3>所在库:&lt; vector &gt;<br>说明： 顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素<br>创建一个向量：vector&lt; element_type &gt; v;<br>常用成员函数：</li></ul><ul><li><strong>push_back()</strong> 在数组的最后添加一个数据</li><li><strong>pop_back()</strong> 去掉数组的最后一个数据</li><li><strong>at()</strong> 得到编号位置的数据</li><li><strong>begin()</strong> 得到数组头的指针</li><li><strong>end()</strong> 得到数组的最后一个单元+1的指针</li><li><strong>front()</strong> 得到数组头的引用</li><li><strong>back()</strong> 得到数组的最后一个单元的引用</li><li><strong>max_size()</strong> 得到vector最大可以是多大</li><li><strong>capacity()</strong> 当前vector分配的大小</li><li><strong>size()</strong> 当前使用数据的大小</li><li><strong>resize()</strong> 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</li><li><strong>reserve()</strong> 改变当前vecotr所分配空间的大小</li><li><strong>erase()</strong> 删除指针指向的数据项</li><li><strong>clear()</strong> 清空当前的vector</li><li><strong>rbegin()</strong> 将vector反转后的开始指针返回(其实就是原来的end-1)</li><li><strong>rend()</strong> 将vector反转构的结束指针返回(其实就是原来的begin-1)</li><li><strong>empty()</strong> 判断vector是否为空</li><li><strong>swap()</strong> 与另一个vector交换数据 <h3 id="地图map"><a href="#地图map" class="headerlink" title="地图map"></a>地图map</h3>所在库: &lt; map &gt;<br>说明：用于保存&lt; key: value &gt;键值对的数据结构<br>创建一个map：map&lt; key_type,value_type &gt; m;<br>常用功能：</li><li><p><strong>插入</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="number">2018</span>] = <span class="number">520</span>;<span class="comment">//如果不存在键值则插入，存在则修改</span></span><br><span class="line"><span class="comment">// 插入单个值</span></span><br><span class="line">mymap.insert(<span class="built_in">std</span>::pair&lt; <span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'a'</span>, <span class="number">100</span>));</span><br><span class="line">mymap.insert(<span class="built_in">std</span>::pair&lt; <span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'z'</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回插入位置以及是否插入成功</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">ret = mymap.insert(<span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'z'</span>, <span class="number">500</span>));</span><br><span class="line"><span class="keyword">if</span> (ret.second == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"element 'z' already existed"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" with a value of "</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定位置插入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">mymap.insert(it, <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'b'</span>, <span class="number">300</span>));  <span class="comment">//效率更高</span></span><br><span class="line">mymap.insert(it, <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'c'</span>, <span class="number">400</span>));  <span class="comment">//效率非最高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//范围多值插入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; anothermap;</span><br><span class="line">anothermap.insert(mymap.begin(), mymap.find(<span class="string">'c'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表形式插入</span></span><br><span class="line">anothermap.insert(&#123; &#123; <span class="string">'d'</span>, <span class="number">100</span> &#125;, &#123;<span class="string">'e'</span>, <span class="number">200</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取值</strong><br>Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ap&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; ID_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ID_Name中没有关键字2016，使用[]取值会导致插入</span></span><br><span class="line"><span class="comment">//因此，下面语句不会报错，但打印结果为空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ID_Name[<span class="number">2016</span>].c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用at会进行关键字检查，因此下面语句会报错</span></span><br><span class="line">ID_Name.at(<span class="number">2016</span>) = <span class="string">"Bob"</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>容量查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map中键值对的数量</span></span><br><span class="line"><span class="keyword">size_t</span> size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map所能包含的最大键值对数量，和系统和应用库有关。</span></span><br><span class="line"><span class="comment">// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了</span></span><br><span class="line"><span class="keyword">size_t</span> max_size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询关键字为key的元素的个数，在map里结果非0即1</span></span><br><span class="line"><span class="keyword">size_t</span> count( <span class="keyword">const</span> Key&amp; key ) <span class="keyword">const</span>; <span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 删除一定范围内的元素，并返回一个指向下一元素的迭代器</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1</span></span><br><span class="line"><span class="keyword">size_t</span> erase( <span class="keyword">const</span> key_type&amp; key );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空map，清空后的size为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>交换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个关键字在map中的先后顺序</span></span><br><span class="line"><span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::key_compare mycomp = mymap.key_comp();</span><br><span class="line"></span><br><span class="line">mymap[<span class="string">'a'</span>]=<span class="number">100</span>;</span><br><span class="line">mymap[<span class="string">'b'</span>]=<span class="number">200</span>;</span><br><span class="line">mycomp(<span class="string">'a'</span>, <span class="string">'b'</span>);  <span class="comment">// a排在b前面，因此返回结果为true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器</span></span><br><span class="line"><span class="comment">// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进行中 </tag>
            
            <tag> C++语法 </tag>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WinSocket编程实现web_server</title>
      <link href="/2018/11/25/Web-server/"/>
      <url>/2018/11/25/Web-server/</url>
      
        <content type="html"><![CDATA[<p>计算机网络实验：用Winsocket编写一个web服务器。要求：能够处理响应报文，发送各种类型的文件，多线程实现。<br><a id="more"></a></p><h2 id="Winsocket介绍"><a href="#Winsocket介绍" class="headerlink" title="Winsocket介绍"></a>Winsocket介绍</h2><h3 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h3><p>由于老师上课的时候从来没有具体的讲过Socket编程，因此，什么是Socket编程便成了我的第一个问题。<br>通俗的来讲socket编程就是为了来写可以联网的应用程序的。像我们平常使用的qq，它其实是一个程序，程序是静态的概念，就是一段代码。当我们双击qq图标时。操作系统将这段代码加载到内存中并分配相应的内存空间，此时便产生了一个进程。当我们再次双击图标时，程序又会再次加载一遍生成另外一个进程。Socket就是为了实现不同电脑（主机）上的不同进程之间的通信问题的一个编程接口。它是一个接口（称为套接字）你只需要将数据扔给他，他就会将数据传送到相互通信的另一个套接字中，而不需要关注数据是如何在运输层和链路层运输的。当有数据传输给你时，你只需要从socket中去取数据即可。</p><h3 id="winSocket介绍"><a href="#winSocket介绍" class="headerlink" title="winSocket介绍"></a>winSocket介绍</h3><p>WinSocket是windows系统下的Socket编程api。<br>Winsock 是通过动态链接库的方式提供给软件开发者，而且从Windows 95以后已经被集成到了Windows操作系统中。Winsock主要经历了2个版本：Winsock 1.1和Winsock 2.0。Winsock 2.0是Winsock 1.1的扩展，它向下完全兼容。Winsock同时包括了16位和32位的编程接口，16位的Windows Socket 2应用程序使用的动态链接库是WINSOCK.DLL，而32位的Windows Socket应用程序使用WSOCK32.DLL（Winsock 1.1版）和WS2_32.DLL（Winsock 2.0版）。另外，使用Winsock API时要包含头文件winsock.h（Winsock 1.1版）或winsock2.h（Winsock 2.0版）。  </p><h3 id="Socket编程的一般步骤"><a href="#Socket编程的一般步骤" class="headerlink" title="Socket编程的一般步骤"></a>Socket编程的一般步骤</h3><p>流程图如下<br><img src="1.png" alt=""></p><ul><li><strong>步骤A：</strong> 初始化,为Winsocket调用准备环境。</li><li><strong>步骤B：</strong> 建立一个监听套接字（用于监听连接请求）。</li><li><strong>步骤C：</strong> 绑定端口号（默认80）主机网卡等信息。</li><li><strong>步骤D：</strong> 开始监听。</li><li><strong>步骤E：</strong> 接收到请求连接，新建立一个连接套接字负责和请求方通讯。</li><li><strong>步骤F：</strong> 收发信息。</li><li><strong>步骤G：</strong> 关闭socket连接。</li></ul><p>如需查找相关函数定义请下载<a href="https://github.com/loveshrimp/web-server" target="_blank" rel="noopener">文档</a></p><h2 id="Web服务器的实现"><a href="#Web服务器的实现" class="headerlink" title="Web服务器的实现"></a>Web服务器的实现</h2><p><strong>需要实现的功能</strong></p><ol><li>可配置Web服务器的监听地址、监听端口和虚拟路径。</li><li>从连接套接字接收http请求报文，并根据请求报文的确定用户请求的网页文件；</li><li>支持多线程，能够针对每一个新的请求创建新的线程，每个客户请求启动一个线程为该客户服务；</li><li>服务可以启动和关闭。</li></ol><h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>该功能只需设立全局变量，在用户启动时提示配置。其中监听地址和监听端口只需在bond()的时候当作参数传入即可。虚拟路径在打开文件时与文件名拼接成绝对路径使用。为了降低用户配置难度和测试方便性，增设默认配置选项。</p><h3 id="发送资源"><a href="#发送资源" class="headerlink" title="发送资源"></a>发送资源</h3><p>首先，接收到一个http请求的时候，对请求进行分析。例如如果浏览器请求一个hello.html文件。服务器得到的报文为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.html HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36</span><br><span class="line">Accept: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class="line">Referer: http://127.0.0.1/hello.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br></pre></td></tr></table></figure></p><p>通过对报文分析，可以得到申请的文件名”hello.html”（通过自己定义的get_filename()得到，详见代码，文末附上），然后通过提前配置的虚拟路径与文件名拼接成为浏览器所申请文件的绝对路径。再通过send_file()函数发送资源。get_filename()和send_file()两个函数是相对容易出问题的点。另外发送的时候构造的报文需要加上contant-length（为了告诉浏览器何时文件发送完毕，停止接收。）否则浏览器将一直处于接受状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">get_filename()函数定义：</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_filename</span><span class="params">(<span class="keyword">char</span>* buf,<span class="keyword">int</span> buflen,<span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">*函数功能：截取浏览器响应报文中申请的文件名并返回</span></span></span><br><span class="line"><span class="function"><span class="comment">*输入：char* buf接受响应报文缓冲区</span></span></span><br><span class="line"><span class="function"><span class="comment">*输出：char *filename申请的目标文件</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line">send_file()函数定义：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_file</span><span class="params">(SOCKET soc, <span class="keyword">char</span> *buf, <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">*函数功能：根据响应报文发送指定文件</span></span></span><br><span class="line"><span class="function"><span class="comment">*输入：SOCKET soc用于通信的套接字</span></span></span><br><span class="line"><span class="function"><span class="comment">*char *buf接收缓冲区</span></span></span><br><span class="line"><span class="function"><span class="comment">*int buflen缓冲区大小</span></span></span><br><span class="line"><span class="function"><span class="comment">*返回值：成功1 失败0</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure></p><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><p>想法是对每个接收到的连接请求都开一个新的线程与之通信。定义一个线程池用于存储一定数量的connectsocket，如果请求来到，并且线程池内有可用线程时，将该线程分配出去，并且将线程状态设为占用，每次有新请求时对线程池的每个线程进行遍历，发现未使用线程时就分配。如果线程池内所有线程均处于占用状态并且还有新请求到来时，请求进行排队。（详见代码）<br>通讯线程的入口函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">communicat</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line">传入参数的结构定义：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadParameter</span> &#123;</span></span><br><span class="line">SOCKET ConnectSocket;<span class="comment">//负责通信的套接字</span></span><br><span class="line">SOCKADDR_IN addrClient;<span class="comment">//地址</span></span><br><span class="line"><span class="keyword">bool</span> state;<span class="comment">//该套接字当前状态，占用1，否则0；</span></span><br><span class="line">HANDLE thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多线程实现流程图：<br><img src="2.png" alt=""></p><h3 id="服务启动和关闭"><a href="#服务启动和关闭" class="headerlink" title="服务启动和关闭"></a>服务启动和关闭</h3><p>要想实现在监听过程中对命令的实时反应。想法是另开一个线程监听键盘输入，然后在主线程的循环中对，接收到的命令做出处理。实现过程可参考上方的流程图。为了实现实时处理，将listensocket设为非阻塞模式。</p><h3 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h3><p><a href="https://github.com/loveshrimp/web-server" target="_blank" rel="noopener">点击这里</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>socket通讯流程大同小异，熟悉了winsocket对于其它语言的socket编程也就容易掌握。重点在于报文的处理。虽然该实验实现了多线程，但是自己对于多线程的理解还不是很深刻，特别是不同线程之间的同步和互斥在windows下没有暴露出太多问题。在以后需要编写多线程的实践中，要加强对着一部分的实践和理解。另外有时间了要学一学写ui啊，控制台界面实在看不下去了😭。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinSocket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> web_server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法3：买卖股票的最佳时机</title>
      <link href="/2018/11/24/%E7%AE%97%E6%B3%953%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2018/11/24/%E7%AE%97%E6%B3%953%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>该问题有四道题，难度依次递增，分别是:买卖股票的最佳时机Ⅰ(leetcode-121)，买卖股票的最佳时机Ⅱ(leetcode-122)，买卖股票的最佳时机III(leetcode-123)，买卖股票的最佳时机Ⅳ(leetcode-188)。<br><a id="more"></a></p><h2 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>要求只允许完成一次交易，那么只需对股票价格进行一次遍历，找到prices[j]-prices[i] (j&gt;i)的最大值即可。时间复杂度O(n)。</p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; min)</span><br><span class="line">min = prices[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] - min &gt; profit)</span><br><span class="line">profit = prices[i] - min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-0版本"><a href="#2-0版本" class="headerlink" title="2.0版本"></a>2.0版本</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>与1.0版本相比，2.0允许你尽可能多的完成交易。在我们提前知道未来股价变化的情况下，我们肯定低买高售，即我们只需找到股价所有递增区间，并将递增值累加即可。依然只需一次遍历。</p><h3 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>])</span><br><span class="line">profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-0版本"><a href="#3-0版本" class="headerlink" title="3.0版本"></a>3.0版本</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h3 id="问题分析：-1"><a href="#问题分析：-1" class="headerlink" title="问题分析："></a>问题分析：</h3><p>与前两个版本相比，该版本规定最多只能完成两笔交易。该问题可以划分为两个1.0版本，然后对两笔交易求和，最终求得和的最大利润。1.0的时间复杂度O(n)，而分割点的个数为n-1，因此该算法时间复杂度为O($n^2$)。</p><h3 id="我的代码：-1"><a href="#我的代码：-1" class="headerlink" title="我的代码："></a>我的代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit3_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = end - start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>||len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min = prices[start], profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; min)</span><br><span class="line">min = prices[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] - min &gt; profit)</span><br><span class="line">profit = prices[i] - min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>||len == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len<span class="number">-1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = maxProfit3_1(prices, <span class="number">0</span>, k) + maxProfit3_1(prices, k + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p &gt; profit)</span><br><span class="line">profit = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (profit &lt; maxProfit3_1(prices, <span class="number">0</span>, len - <span class="number">1</span>)) profit = maxProfit3_1(prices, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><p>前两道时间复杂度为O(n)在leetcode提交时速度是最快的(4ms)，但是第3题两次复用第一题，时间复杂度为O($n^2$)运行时间达到了800+ms(击败4%的提交)显然这种方法太低效了。于是参考了Discuss上主流的经典高效解法，竟然把时间复杂度降到O(n)，佩服啊。在理解算法的同时也要学习for( : )这种便利写法以及 &lt; limit &gt;的用法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit3p</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 同Discuss的主流经典高效解法，相当于第一题的加强版</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 初始状态</span></span></span><br><span class="line"><span class="function"><span class="comment"> **/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> buy1 = INT_MIN, sell1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> buy2 = INT_MIN, sell2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line"><span class="comment">// 第一次购买</span></span><br><span class="line"><span class="keyword">if</span> (buy1 &lt; -price) buy1 = -price;</span><br><span class="line"><span class="comment">// 第一次卖出去的可能的最大利润</span></span><br><span class="line"><span class="keyword">if</span> (sell1 &lt; buy1 + price) sell1 = buy1 + price;</span><br><span class="line"><span class="comment">//注意第二次的利润已经包含第一次的了</span></span><br><span class="line"><span class="comment">//同理，第二次购买,注意这里是</span></span><br><span class="line"><span class="keyword">if</span> (buy2 &lt; sell1 - price) buy2 = sell1 - price;</span><br><span class="line"><span class="comment">//最后一次</span></span><br><span class="line"><span class="keyword">if</span> (sell2 &lt; buy2 + price) sell2 = buy2 + price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sell2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-0版本"><a href="#4-0版本" class="headerlink" title="4.0版本"></a>4.0版本</h2><h3 id="坑待填…"><a href="#坑待填…" class="headerlink" title="坑待填…"></a>坑待填…</h3>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法2：扫雷小游戏（leetcode-529）</title>
      <link href="/2018/11/24/%E7%AE%97%E6%B3%952%EF%BC%9A%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/11/24/%E7%AE%97%E6%B3%952%EF%BC%9A%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>实现扫雷小游戏的游戏逻辑。<br><a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个代表游戏板的二维字符矩阵。 ‘<strong>M</strong>‘ 代表一个<strong>未挖出</strong>的地雷，’<strong>E</strong>‘ 代表一个未挖出的空方块，’<strong>B</strong>‘ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出</strong>的空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’<strong>X</strong>‘ 则表示一个<strong>已挖出</strong>的地雷。</p><p>现在给出在所有<strong>未挖出</strong>的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘<strong>X</strong>‘。</li><li>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且 所有和其相邻的方块都应该被递归地揭露。</li><li>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。  </li></ol><p><strong>示例 1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:   </span><br><span class="line"></span><br><span class="line">[[&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="minesweeper_example_1.png" alt=""><br><strong>示例 2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="minesweeper_example_2.png" alt=""><br>注意:</p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。  </li></ol><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;square;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;square&gt; q;</span><br><span class="line">square sq_unexplore,sq_explore,sq_click;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_of_M; <span class="comment">//用于统计挖出的空方块周围的地雷数</span></span><br><span class="line"><span class="keyword">int</span> i,j,x,y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = board.size();</span><br><span class="line"><span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">sq_click.x = click[<span class="number">0</span>];</span><br><span class="line">sq_click.y = click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q.push(sq_click);<span class="comment">//将首次点击的方块加入队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">sq_explore = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">num_of_M = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (board[sq_explore.x][sq_explore.y] == <span class="string">'M'</span>)<span class="comment">//挖出地雷，游戏结束</span></span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//挖出空方快，如果周围有地雷，显示地雷个数，</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看周围八个方块</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//不用探索自身</span></span><br><span class="line">x = sq_explore.x + i;</span><br><span class="line">y = sq_explore.y + j;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x &gt;= rows) || (y &lt; <span class="number">0</span>) || (y &gt;= cols)) <span class="keyword">continue</span>;<span class="comment">//判是否越界</span></span><br><span class="line"><span class="keyword">if</span> (board[x][y] == <span class="string">'M'</span>) num_of_M++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num_of_M != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="keyword">char</span>(num_of_M + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//不用探索自身</span></span><br><span class="line">x = sq_explore.x + i;</span><br><span class="line">y = sq_explore.y + j;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x &gt;= rows) || (y &lt; <span class="number">0</span>) || (y &gt;= cols)) <span class="keyword">continue</span>;<span class="comment">//判断是否越界</span></span><br><span class="line"><span class="keyword">if</span> (board[x][y] != <span class="string">'B'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sq_unexplore.x = x;</span><br><span class="line">sq_unexplore.y = y;</span><br><span class="line">q.push(sq_unexplore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>根据题意总结:</p><ul><li>首次点击如果是雷(“M”)，算你倒霉游戏结束(“M”置为”X)</li><li>首次点击如果不是雷则探索周围八个方格(注意越界的和以判断过的不用再探索)</li><li>如果周围八个方格内有雷，则刷新点击的方格(将”E”置为雷的个数)</li><li>如果周围八个方格内没有雷，则刷新点击的方格(将”E”置为”B”)并且以同样方法点击周围八个方格(除去已点击过的和越界的)<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3>根据以上分析可以看出只需使用BFS遍历click即可。使用队列将需要遍历的节点存起来。定义一个数据结构square来保存方块信息。如果需要点击周围的方块，则将周围方块入队列（除去越界的和已遍历过的），点击完后出队列。遍历结束的条件是队列为空。<br>该方法是可行的，也是容易想到的。不过在雷盘较大时，队列占用空间较大，不能满足leetcode测试的内存限制。因此只能通过测试用例(28/54)。至于如何改进暂时没有想到（第一次写BFS的题，有点菜）。最近老是被时间和空间限制所困扰，自己以前写的程序里从来没有考虑这些东西，还是慢慢积累经验吧。  </li></ul><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>待改进…</p>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法1：验证IP（leetcode-468）</title>
      <link href="/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/"/>
      <url>/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。<br><a id="more"></a></p><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p><strong>IPv4</strong>：地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；<br>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p><p><strong>IPv6</strong>：地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。<br>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。<br>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。 </p><p><strong>说明</strong>: 你可以认为给定的字符串里没有空格或者其他特殊字符。  </p><p><strong>示例 1</strong>:  </p><blockquote><p>输入: “172.16.254.1”</p><p>输出: “IPv4”</p></blockquote><p>解释: 这是一个有效的 IPv4 地址, 所以返回 “IPv4”。</p><p><strong>示例 2</strong>:  </p><blockquote><p>输入: “2001:0db8:85a3:0:0:8A2E:0370:7334”</p><p>输出: “IPv6”</p></blockquote><p>解释: 这是一个有效的 IPv6 地址, 所以返回 “IPv6”。</p><p><strong>示例 3</strong>:  </p><blockquote><p>输入: “256.256.256.256”</p><p>输出: “Neither”</p></blockquote><p>解释: 这个地址既不是 IPv4 也不是 IPv6 地址。</p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIPv4</span><span class="params">(<span class="built_in">string</span> IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern&#123; <span class="string">"(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;"</span> &#125;;</span><br><span class="line"><span class="function">regex <span class="title">re</span><span class="params">(pattern)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(regex_match(IP, re))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIPv6</span><span class="params">(<span class="built_in">string</span> IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern&#123; <span class="string">"([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;"</span> &#125;;</span><br><span class="line"><span class="function">regex <span class="title">re</span><span class="params">(pattern)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (regex_match(IP, re))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(isIPv4(IP) ? <span class="string">"IPv4"</span>: (isIPv6(IP) ? <span class="string">"IPv6"</span>:<span class="string">"Neither"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>首先是方法的选择（如果不用正则表达式将会很麻烦）</li><li>正则表达式的书写</li><li>C++正则表达式的用法<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3></li></ul><ol><li><p>C++正则表达式介绍参见（<a href="https://blog.csdn.net/fengbingchun/article/details/54835571" target="_blank" rel="noopener">文章一</a>，<a href="https://www.cnblogs.com/ittinybird/p/4853532.html" target="_blank" rel="noopener">文章二</a>）</p></li><li><p>正则表达式的书写是一大难点需要多加练习加以积累。在本题中难点是ipv4的正则表达式书写。主要学会如何表示[0-255]的数。根据各部分的特征可以将这些数分为。</p><blockquote><ul><li>0-99:([1-9]?[0-9])</li><li>100-199:(1[0-9]{2})</li><li>200-249:(24[0-9])</li><li>250-255:(25[0-5])</li></ul></blockquote></li></ol><p>需要注意的有两点：一是对”.”的转义，二是或运算符的优先级最低，因此遇到多个或运算的时候每个部分都要加上括号避免出现二义性。<br>3.正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipv4:(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;</span><br><span class="line">ipv6:([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;</span><br></pre></td></tr></table></figure></p><p>本题在掌握正则表达式后相对比较简单，对于正则表达式的书写还得再多加练习。然而正则虽好，编译器起来太耗时间了，该代码在leetcode上的执行用时60ms（击败0%的用户），emmmm….，好吧还是我太菜，不用正则的话能想到的改进就是c语言中的strchr()和strrchr()或者用类似python中的split()来处理字符串。后面再测试测试。  </p><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>待改进…</p>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
