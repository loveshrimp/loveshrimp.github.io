<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>WinSocket编程实现web_server</title>
      <link href="/2018/11/25/Web-server/"/>
      <url>/2018/11/25/Web-server/</url>
      
        <content type="html"><![CDATA[<p>计算机网络实验：用Winsocket编写一个web服务器。要求：能够处理响应报文，发送各种类型的文件，多线程实现。<br><a id="more"></a></p><h2 id="Winsocket介绍"><a href="#Winsocket介绍" class="headerlink" title="Winsocket介绍"></a>Winsocket介绍</h2><h3 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h3><p>由于老师上课的时候从来没有具体的讲过Socket编程，因此，什么是Socket编程便成了我的第一个问题。<br>通俗的来讲socket编程就是为了来写可以联网的应用程序的。像我们平常使用的qq，它其实是一个程序，程序是静态的概念，就是一段代码。当我们双击qq图标时。操作系统将这段代码加载到内存中并分配相应的内存空间，此时便产生了一个进程。当我们再次双击图标时，程序又会再次加载一遍生成另外一个进程。Socket就是为了实现不同电脑（主机）上的不同进程之间的通信问题的一个编程接口。它是一个接口（称为套接字）你只需要将数据扔给他，他就会将数据传送到相互通信的另一个套接字中，而不需要关注数据是如何在运输层和链路层运输的。当有数据传输给你时，你只需要从socket中去取数据即可。</p><h3 id="winSocket介绍"><a href="#winSocket介绍" class="headerlink" title="winSocket介绍"></a>winSocket介绍</h3><p>WinSocket是windows系统下的Socket编程api。<br>Winsock 是通过动态链接库的方式提供给软件开发者，而且从Windows 95以后已经被集成到了Windows操作系统中。Winsock主要经历了2个版本：Winsock 1.1和Winsock 2.0。Winsock 2.0是Winsock 1.1的扩展，它向下完全兼容。Winsock同时包括了16位和32位的编程接口，16位的Windows Socket 2应用程序使用的动态链接库是WINSOCK.DLL，而32位的Windows Socket应用程序使用WSOCK32.DLL（Winsock 1.1版）和WS2_32.DLL（Winsock 2.0版）。另外，使用Winsock API时要包含头文件winsock.h（Winsock 1.1版）或winsock2.h（Winsock 2.0版）。  </p><h3 id="Socket编程的一般步骤"><a href="#Socket编程的一般步骤" class="headerlink" title="Socket编程的一般步骤"></a>Socket编程的一般步骤</h3><p>流程图如下<br><img src="1.png" alt=""></p><ul><li><strong>步骤A：</strong> 初始化,为Winsocket调用准备环境。</li><li><strong>步骤B：</strong> 建立一个监听套接字（用于监听连接请求）。</li><li><strong>步骤C：</strong> 绑定端口号（默认80）主机网卡等信息。</li><li><strong>步骤D：</strong> 开始监听。</li><li><strong>步骤E：</strong> 接收到请求连接，新建立一个连接套接字负责和请求方通讯。</li><li><strong>步骤F：</strong> 收发信息。</li><li><strong>步骤G：</strong> 关闭socket连接。</li></ul><p>如需查找相关函数定义请下载<a href="https://github.com/loveshrimp/web-server" target="_blank" rel="noopener">文档</a></p><h2 id="Web服务器的实现"><a href="#Web服务器的实现" class="headerlink" title="Web服务器的实现"></a>Web服务器的实现</h2><p><strong>需要实现的功能</strong></p><ol><li>可配置Web服务器的监听地址、监听端口和虚拟路径。</li><li>从连接套接字接收http请求报文，并根据请求报文的确定用户请求的网页文件；</li><li>支持多线程，能够针对每一个新的请求创建新的线程，每个客户请求启动一个线程为该客户服务；</li><li>服务可以启动和关闭。</li></ol><h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>该功能只需设立全局变量，在用户启动时提示配置。其中监听地址和监听端口只需在bond()的时候当作参数传入即可。虚拟路径在打开文件时与文件名拼接成绝对路径使用。为了降低用户配置难度和测试方便性，增设默认配置选项。</p><h3 id="发送资源"><a href="#发送资源" class="headerlink" title="发送资源"></a>发送资源</h3><p>首先，接收到一个http请求的时候，对请求进行分析。例如如果浏览器请求一个hello.html文件。服务器得到的报文为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.html HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36</span><br><span class="line">Accept: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class="line">Referer: http://127.0.0.1/hello.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br></pre></td></tr></table></figure></p><p>通过对报文分析，可以得到申请的文件名”hello.html”（通过自己定义的get_filename()得到，详见代码，文末附上），然后通过提前配置的虚拟路径与文件名拼接成为浏览器所申请文件的绝对路径。再通过send_file()函数发送资源。get_filename()和send_file()两个函数是相对容易出问题的点。另外发送的时候构造的报文需要加上contant-length（为了告诉浏览器何时文件发送完毕，停止接收。）否则浏览器将一直处于接受状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">get_filename()函数定义：</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_filename</span><span class="params">(<span class="keyword">char</span>* buf,<span class="keyword">int</span> buflen,<span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">*函数功能：截取浏览器响应报文中申请的文件名并返回</span></span></span><br><span class="line"><span class="function"><span class="comment">*输入：char* buf接受响应报文缓冲区</span></span></span><br><span class="line"><span class="function"><span class="comment">*输出：char *filename申请的目标文件</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line">send_file()函数定义：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_file</span><span class="params">(SOCKET soc, <span class="keyword">char</span> *buf, <span class="keyword">int</span> buflen)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">*函数功能：根据响应报文发送指定文件</span></span></span><br><span class="line"><span class="function"><span class="comment">*输入：SOCKET soc用于通信的套接字</span></span></span><br><span class="line"><span class="function"><span class="comment">*char *buf接收缓冲区</span></span></span><br><span class="line"><span class="function"><span class="comment">*int buflen缓冲区大小</span></span></span><br><span class="line"><span class="function"><span class="comment">*返回值：成功1 失败0</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure></p><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><p>想法是对每个接收到的连接请求都开一个新的线程与之通信。定义一个线程池用于存储一定数量的connectsocket，如果请求来到，并且线程池内有可用线程时，将该线程分配出去，并且将线程状态设为占用，每次有新请求时对线程池的每个线程进行遍历，发现未使用线程时就分配。如果线程池内所有线程均处于占用状态并且还有新请求到来时，请求进行排队。（详见代码）<br>通讯线程的入口函数定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">communicat</span><span class="params">(LPVOID pParam)</span></span></span><br><span class="line">传入参数的结构定义：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadParameter</span> &#123;</span></span><br><span class="line">SOCKET ConnectSocket;<span class="comment">//负责通信的套接字</span></span><br><span class="line">SOCKADDR_IN addrClient;<span class="comment">//地址</span></span><br><span class="line"><span class="keyword">bool</span> state;<span class="comment">//该套接字当前状态，占用1，否则0；</span></span><br><span class="line">HANDLE thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多线程实现流程图：<br><img src="2.png" alt=""></p><h3 id="服务启动和关闭"><a href="#服务启动和关闭" class="headerlink" title="服务启动和关闭"></a>服务启动和关闭</h3><p>要想实现在监听过程中对命令的实时反应。想法是另开一个线程监听键盘输入，然后在主线程的循环中对，接收到的命令做出处理。实现过程可参考上方的流程图。为了实现实时处理，将listensocket设为非阻塞模式。</p><h3 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h3><p><a href="https://github.com/loveshrimp/web-server" target="_blank" rel="noopener">点击这里</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>socket通讯流程大同小异，熟悉了winsocket对于其它语言的socket编程也就容易掌握。重点在于报文的处理。虽然该实验实现了多线程，但是自己对于多线程的理解还不是很深刻，特别是不同线程之间的同步和互斥在windows下没有暴露出太多问题。在以后需要编写多线程的实践中，要加强对着一部分的实践和理解。另外有时间了要学一学写ui啊，控制台界面实在看不下去了😭。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinSocket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> web_server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法3：买卖股票的最佳时机</title>
      <link href="/2018/11/24/%E7%AE%97%E6%B3%953%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2018/11/24/%E7%AE%97%E6%B3%953%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>该问题有四道题，难度依次递增，分别是:买卖股票的最佳时机Ⅰ(leetcode-121)，买卖股票的最佳时机Ⅱ(leetcode-122)，买卖股票的最佳时机III(leetcode-123)，买卖股票的最佳时机Ⅳ(leetcode-188)。<br><a id="more"></a></p><h2 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>要求只允许完成一次交易，那么只需对股票价格进行一次遍历，找到prices[j]-prices[i] (j&gt;i)的最大值即可。时间复杂度O(n)。</p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; min)</span><br><span class="line">min = prices[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] - min &gt; profit)</span><br><span class="line">profit = prices[i] - min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-0版本"><a href="#2-0版本" class="headerlink" title="2.0版本"></a>2.0版本</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>与1.0版本相比，2.0允许你尽可能多的完成交易。在我们提前知道未来股价变化的情况下，我们肯定低买高售，即我们只需找到股价所有递增区间，并将递增值累加即可。依然只需一次遍历。</p><h3 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>])</span><br><span class="line">profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-0版本"><a href="#3-0版本" class="headerlink" title="3.0版本"></a>3.0版本</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h3 id="问题分析：-1"><a href="#问题分析：-1" class="headerlink" title="问题分析："></a>问题分析：</h3><p>与前两个版本相比，该版本规定最多只能完成两笔交易。该问题可以划分为两个1.0版本，然后对两笔交易求和，最终求得和的最大利润。1.0的时间复杂度O(n)，而分割点的个数为n-1，因此该算法时间复杂度为O($n^2$)。</p><h3 id="我的代码：-1"><a href="#我的代码：-1" class="headerlink" title="我的代码："></a>我的代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit3_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = end - start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>||len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min = prices[start], profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; min)</span><br><span class="line">min = prices[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] - min &gt; profit)</span><br><span class="line">profit = prices[i] - min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>||len == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len<span class="number">-1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = maxProfit3_1(prices, <span class="number">0</span>, k) + maxProfit3_1(prices, k + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p &gt; profit)</span><br><span class="line">profit = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (profit &lt; maxProfit3_1(prices, <span class="number">0</span>, len - <span class="number">1</span>)) profit = maxProfit3_1(prices, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><p>前两道时间复杂度为O(n)在leetcode提交时速度是最快的(4ms)，但是第二题两次复用第一题，时间复杂度为O($n^2$)运行时间达到了800+ms(击败4%的提交)显然这种方法太低效了。于是参考了Discuss上主流的经典高效解法，竟然把时间复杂度降到O(n)，佩服啊。在理解算法的同时也要学习for( : )这种便利写法以及 &lt; limit &gt;的用法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit3p</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 同Discuss的主流经典高效解法，相当于第一题的加强版</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 初始状态</span></span></span><br><span class="line"><span class="function"><span class="comment"> **/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> buy1 = INT_MIN, sell1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> buy2 = INT_MIN, sell2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line"><span class="comment">// 第一次购买</span></span><br><span class="line"><span class="keyword">if</span> (buy1 &lt; -price) buy1 = -price;</span><br><span class="line"><span class="comment">// 第一次卖出去的可能的最大利润</span></span><br><span class="line"><span class="keyword">if</span> (sell1 &lt; buy1 + price) sell1 = buy1 + price;</span><br><span class="line"><span class="comment">//注意第二次的利润已经包含第一次的了</span></span><br><span class="line"><span class="comment">//同理，第二次购买,注意这里是</span></span><br><span class="line"><span class="keyword">if</span> (buy2 &lt; sell1 - price) buy2 = sell1 - price;</span><br><span class="line"><span class="comment">//最后一次</span></span><br><span class="line"><span class="keyword">if</span> (sell2 &lt; buy2 + price) sell2 = buy2 + price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sell2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-0版本"><a href="#4-0版本" class="headerlink" title="4.0版本"></a>4.0版本</h2><h3 id="坑待填…"><a href="#坑待填…" class="headerlink" title="坑待填…"></a>坑待填…</h3>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法2：扫雷小游戏（leetcode-529）</title>
      <link href="/2018/11/24/%E7%AE%97%E6%B3%952%EF%BC%9A%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/11/24/%E7%AE%97%E6%B3%952%EF%BC%9A%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>实现扫雷小游戏的游戏逻辑。<br><a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个代表游戏板的二维字符矩阵。 ‘<strong>M</strong>‘ 代表一个<strong>未挖出</strong>的地雷，’<strong>E</strong>‘ 代表一个未挖出的空方块，’<strong>B</strong>‘ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出</strong>的空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’<strong>X</strong>‘ 则表示一个<strong>已挖出</strong>的地雷。</p><p>现在给出在所有<strong>未挖出</strong>的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘<strong>X</strong>‘。</li><li>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且 所有和其相邻的方块都应该被递归地揭露。</li><li>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。  </li></ol><p><strong>示例 1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:   </span><br><span class="line"></span><br><span class="line">[[&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="minesweeper_example_1.png" alt=""><br><strong>示例 2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="minesweeper_example_2.png" alt=""><br>注意:</p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。  </li></ol><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;square;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;square&gt; q;</span><br><span class="line">square sq_unexplore,sq_explore,sq_click;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_of_M; <span class="comment">//用于统计挖出的空方块周围的地雷数</span></span><br><span class="line"><span class="keyword">int</span> i,j,x,y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = board.size();</span><br><span class="line"><span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">sq_click.x = click[<span class="number">0</span>];</span><br><span class="line">sq_click.y = click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q.push(sq_click);<span class="comment">//将首次点击的方块加入队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">sq_explore = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">num_of_M = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (board[sq_explore.x][sq_explore.y] == <span class="string">'M'</span>)<span class="comment">//挖出地雷，游戏结束</span></span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//挖出空方快，如果周围有地雷，显示地雷个数，</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看周围八个方块</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//不用探索自身</span></span><br><span class="line">x = sq_explore.x + i;</span><br><span class="line">y = sq_explore.y + j;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x &gt;= rows) || (y &lt; <span class="number">0</span>) || (y &gt;= cols)) <span class="keyword">continue</span>;<span class="comment">//判是否越界</span></span><br><span class="line"><span class="keyword">if</span> (board[x][y] == <span class="string">'M'</span>) num_of_M++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num_of_M != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="keyword">char</span>(num_of_M + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//不用探索自身</span></span><br><span class="line">x = sq_explore.x + i;</span><br><span class="line">y = sq_explore.y + j;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x &gt;= rows) || (y &lt; <span class="number">0</span>) || (y &gt;= cols)) <span class="keyword">continue</span>;<span class="comment">//判断是否越界</span></span><br><span class="line"><span class="keyword">if</span> (board[x][y] != <span class="string">'B'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sq_unexplore.x = x;</span><br><span class="line">sq_unexplore.y = y;</span><br><span class="line">q.push(sq_unexplore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>根据题意总结:</p><ul><li>首次点击如果是雷(“M”)，算你倒霉游戏结束(“M”置为”X)</li><li>首次点击如果不是雷则探索周围八个方格(注意越界的和以判断过的不用再探索)</li><li>如果周围八个方格内有雷，则刷新点击的方格(将”E”置为雷的个数)</li><li>如果周围八个方格内没有雷，则刷新点击的方格(将”E”置为”B”)并且以同样方法点击周围八个方格(除去已点击过的和越界的)<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3>根据以上分析可以看出只需使用BFS遍历click即可。使用队列将需要遍历的节点存起来。定义一个数据结构square来保存方块信息。如果需要点击周围的方块，则将周围方块入队列（除去越界的和已遍历过的），点击完后出队列。遍历结束的条件是队列为空。<br>该方法是可行的，也是容易想到的。不过在雷盘较大时，队列占用空间较大，不能满足leetcode测试的内存限制。因此只能通过测试用例(28/54)。至于如何改进暂时没有想到（第一次写BFS的题，有点菜）。最近老是被时间和空间限制所困扰，自己以前写的程序里从来没有考虑这些东西，还是慢慢积累经验吧。  </li></ul><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>待改进…</p>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法1：验证IP（leetcode-468）</title>
      <link href="/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/"/>
      <url>/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。<br><a id="more"></a></p><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p><strong>IPv4</strong>：地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；<br>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p><p><strong>IPv6</strong>：地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。<br>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。<br>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。 </p><p><strong>说明</strong>: 你可以认为给定的字符串里没有空格或者其他特殊字符。  </p><p><strong>示例 1</strong>:  </p><blockquote><p>输入: “172.16.254.1”</p><p>输出: “IPv4”</p></blockquote><p>解释: 这是一个有效的 IPv4 地址, 所以返回 “IPv4”。</p><p><strong>示例 2</strong>:  </p><blockquote><p>输入: “2001:0db8:85a3:0:0:8A2E:0370:7334”</p><p>输出: “IPv6”</p></blockquote><p>解释: 这是一个有效的 IPv6 地址, 所以返回 “IPv6”。</p><p><strong>示例 3</strong>:  </p><blockquote><p>输入: “256.256.256.256”</p><p>输出: “Neither”</p></blockquote><p>解释: 这个地址既不是 IPv4 也不是 IPv6 地址。</p><h2 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h2><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIPv4</span><span class="params">(<span class="built_in">string</span> IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern&#123; <span class="string">"(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;"</span> &#125;;</span><br><span class="line"><span class="function">regex <span class="title">re</span><span class="params">(pattern)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(regex_match(IP, re))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIPv6</span><span class="params">(<span class="built_in">string</span> IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern&#123; <span class="string">"([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;"</span> &#125;;</span><br><span class="line"><span class="function">regex <span class="title">re</span><span class="params">(pattern)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (regex_match(IP, re))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(isIPv4(IP) ? <span class="string">"IPv4"</span>: (isIPv6(IP) ? <span class="string">"IPv6"</span>:<span class="string">"Neither"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>首先是方法的选择（如果不用正则表达式将会很麻烦）</li><li>正则表达式的书写</li><li>C++正则表达式的用法<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3></li></ul><ol><li><p>C++正则表达式介绍参见（<a href="https://blog.csdn.net/fengbingchun/article/details/54835571" target="_blank" rel="noopener">文章一</a>，<a href="https://www.cnblogs.com/ittinybird/p/4853532.html" target="_blank" rel="noopener">文章二</a>）</p></li><li><p>正则表达式的书写是一大难点需要多加练习加以积累。在本题中难点是ipv4的正则表达式书写。主要学会如何表示[0-255]的数。根据各部分的特征可以将这些数分为。</p><blockquote><ul><li>0-99:([1-9]?[0-9])</li><li>100-199:(1[0-9]{2})</li><li>200-249:(24[0-9])</li><li>250-255:(25[0-5])</li></ul></blockquote></li></ol><p>需要注意的有两点：一是对”.”的转义，二是或运算符的优先级最低，因此遇到多个或运算的时候每个部分都要加上括号避免出现二义性。<br>3.正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipv4:(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;</span><br><span class="line">ipv6:([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;</span><br></pre></td></tr></table></figure></p><p>本题在掌握正则表达式后相对比较简单，对于正则表达式的书写还得再多加练习。然而正则虽好，编译器起来太耗时间了，该代码在leetcode上的执行用时60ms（击败0%的用户），emmmm….，好吧还是我太菜，不用正则的话能想到的改进就是c语言中的strchr()和strrchr()或者用类似python中的split()来处理字符串。后面再测试测试。  </p><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>待改进…</p>]]></content>
      
      
      <categories>
          
          <category> 每周三道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
