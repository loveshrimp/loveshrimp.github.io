<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>算法1：验证IP（leetcode-468）</title>
      <link href="/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/"/>
      <url>/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。<br><a id="more"></a></p><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p><strong>IPv4</strong>：地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；<br>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p><p><strong>IPv6</strong>：地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。<br>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。<br>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。 </p><p><strong>说明</strong>: 你可以认为给定的字符串里没有空格或者其他特殊字符。  </p><p><strong>示例 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;172.16.254.1&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;IPv4&quot;</span><br><span class="line"></span><br><span class="line">解释: 这是一个有效的 IPv4 地址, 所以返回 &quot;IPv4&quot;。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;IPv6&quot;</span><br><span class="line"></span><br><span class="line">解释: 这是一个有效的 IPv6 地址, 所以返回 &quot;IPv6&quot;。</span><br></pre></td></tr></table></figure></p><p><strong>示例 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;256.256.256.256&quot;</span><br><span class="line"></span><br><span class="line">输出: &quot;Neither&quot;</span><br><span class="line"></span><br><span class="line">解释: 这个地址既不是 IPv4 也不是 IPv6 地址。</span><br></pre></td></tr></table></figure></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h2><p>见我的github <a href="https://github.com/loveshrimp/poj_or_leetcode/tree/master/leetcode468" target="_blank" rel="noopener">leetcode-468</a></p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><ul><li>首先是方法的选择（如果不用正则表达式将会很麻烦）</li><li>正则表达式的书写</li><li>C++正则表达式的用法<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2></li></ul><ol><li><p>C++正则表达式介绍参见（<a href="https://blog.csdn.net/fengbingchun/article/details/54835571" target="_blank" rel="noopener">文章一</a>，<a href="https://www.cnblogs.com/ittinybird/p/4853532.html" target="_blank" rel="noopener">文章二</a>）</p></li><li><p>正则表达式的书写是一大难点需要多加练习加以积累。在本题中难点是ipv4的正则表达式书写。主要学会如何表示[0-255]的数。根据各部分的特征可以将这些数分为。</p><blockquote><ul><li>0-99:([1-9]?[0-9])</li><li>100-199:(1[0-9]{2})</li><li>200-249:(24[0-9])</li><li>250-255:(25[0-5])</li></ul></blockquote></li></ol><p>需要注意的有两点：一是对”.”的转义，二是或运算符的优先级最低，因此遇到多个或运算的时候每个部分都要加上括号避免出现二义性。<br>3.正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipv4:(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;</span><br><span class="line">ipv6:([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;</span><br></pre></td></tr></table></figure></p><hr><p>本题在掌握正则表达式后相对比较简单，对于正则表达式的书写还得再多加练习。</p>]]></content>
      
      
      <categories>
          
          <category> 每天一道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WinSocket编程</title>
      <link href="/2018/11/11/WinSocket/"/>
      <url>/2018/11/11/WinSocket/</url>
      
        <content type="html"><![CDATA[<p>计算机网络实验：用Winsocket编写一个web服务器。<br>要求：能够处理响应报文，发送各种类型的文件，多线程实现。代码见我的github：(web_server)[<a href="https://github.com/loveshrimp/web-server]" target="_blank" rel="noopener">https://github.com/loveshrimp/web-server]</a><br><a id="more"></a></p><h1 id="Winsocket介绍"><a href="#Winsocket介绍" class="headerlink" title="Winsocket介绍"></a>Winsocket介绍</h1><h2 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h2><p>由于老师上课的时候从来没有具体的讲过Socket编程，因此，什么是Socket编程便成了我的第一个问题。<br>通俗的来讲socket编程就是为了来写可以联网的应用程序的。像我们平常使用的qq，它其实是一个程序，程序是静态的概念，就是一段代码。当我们双击qq图标时。操作系统将这段代码加载到内存中并分配相应的内存空间，此时便产生了一个进程。当我们再次双击图标时，程序又会再次加载一遍生成另外一个进程。Socket就是为了实现不同电脑（主机）上的不同进程之间的通信问题的一个编程接口。它是一个接口（称为套接字）你只需要将数据扔给他，他就会将数据传送到相互通信的另一个套接字中，而不需要关注数据是如何在运输层和链路层运输的。当有数据传输给你时，你只需要从socket中去取数据即可。</p><h2 id="winSocket介绍"><a href="#winSocket介绍" class="headerlink" title="winSocket介绍"></a>winSocket介绍</h2><p>WinSocket是windows系统下的Socket编程api。<br>Winsock 是通过动态链接库的方式提供给软件开发者，而且从Windows 95以后已经被集成到了Windows操作系统中。Winsock主要经历了2个版本：Winsock 1.1和Winsock 2.0。Winsock 2.0是Winsock 1.1的扩展，它向下完全兼容。Winsock同时包括了16位和32位的编程接口，16位的Windows Socket 2应用程序使用的动态链接库是WINSOCK.DLL，而32位的Windows Socket应用程序使用WSOCK32.DLL（Winsock 1.1版）和WS2_32.DLL（Winsock 2.0版）。另外，使用Winsock API时要包含头文件winsock.h（Winsock 1.1版）或winsock2.h（Winsock 2.0版）。  </p><hr><h1 id="Web-server实验"><a href="#Web-server实验" class="headerlink" title="Web_server实验"></a>Web_server实验</h1><h2 id="Socket编程的一般步骤"><a href="#Socket编程的一般步骤" class="headerlink" title="Socket编程的一般步骤"></a>Socket编程的一般步骤</h2><pre class="mermaid">graph TDA(Init);B(Creat Listen_socket);C(Bind);D(Listen);E(Creat Connect_socket);F(Connection);G(Close Connect_socket);A-->BB-->CC-->DD-- if_request ---EE-->FF-->GG-->Quit</pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinSocket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
