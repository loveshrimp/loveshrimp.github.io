<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>算法2：扫雷小游戏（leetcode-529）</title>
      <link href="/2018/11/24/%E7%AE%97%E6%B3%952%EF%BC%9A%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/11/24/%E7%AE%97%E6%B3%952%EF%BC%9A%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>实现扫雷小游戏的游戏逻辑。<br><a id="more"></a></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个代表游戏板的二维字符矩阵。 ‘<strong>M</strong>‘ 代表一个<strong>未挖出</strong>的地雷，’<strong>E</strong>‘ 代表一个未挖出的空方块，’<strong>B</strong>‘ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出</strong>的空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’<strong>X</strong>‘ 则表示一个<strong>已挖出</strong>的地雷。</p><p>现在给出在所有<strong>未挖出</strong>的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘<strong>X</strong>‘。</li><li>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且 所有和其相邻的方块都应该被递归地揭露。</li><li>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。  </li></ol><p><strong>示例 1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:   </span><br><span class="line"></span><br><span class="line">[[&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</span><br><span class="line"> [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="minesweeper_example_1.png" alt=""><br><strong>示例 2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</span><br><span class="line"> [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="minesweeper_example_2.png" alt=""><br>注意:</p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。  </li></ol><h1 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h1><h2 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;square;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;square&gt; q;</span><br><span class="line">square sq_unexplore,sq_explore,sq_click;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_of_M; <span class="comment">//用于统计挖出的空方块周围的地雷数</span></span><br><span class="line"><span class="keyword">int</span> i,j,x,y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rows = board.size();</span><br><span class="line"><span class="keyword">int</span> cols = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">sq_click.x = click[<span class="number">0</span>];</span><br><span class="line">sq_click.y = click[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q.push(sq_click);<span class="comment">//将首次点击的方块加入队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">sq_explore = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">num_of_M = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (board[sq_explore.x][sq_explore.y] == <span class="string">'M'</span>)<span class="comment">//挖出地雷，游戏结束</span></span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//挖出空方快，如果周围有地雷，显示地雷个数，</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看周围八个方块</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">-1</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//不用探索自身</span></span><br><span class="line">x = sq_explore.x + i;</span><br><span class="line">y = sq_explore.y + j;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x &gt;= rows) || (y &lt; <span class="number">0</span>) || (y &gt;= cols)) <span class="keyword">continue</span>;<span class="comment">//判是否越界</span></span><br><span class="line"><span class="keyword">if</span> (board[x][y] == <span class="string">'M'</span>) num_of_M++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num_of_M != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="keyword">char</span>(num_of_M + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">board[sq_explore.x][sq_explore.y] = <span class="string">'B'</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//不用探索自身</span></span><br><span class="line">x = sq_explore.x + i;</span><br><span class="line">y = sq_explore.y + j;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x &gt;= rows) || (y &lt; <span class="number">0</span>) || (y &gt;= cols)) <span class="keyword">continue</span>;<span class="comment">//判断是否越界</span></span><br><span class="line"><span class="keyword">if</span> (board[x][y] != <span class="string">'B'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sq_unexplore.x = x;</span><br><span class="line">sq_unexplore.y = y;</span><br><span class="line">q.push(sq_unexplore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据题意总结:</p><ul><li>首次点击如果是雷(“M”)，算你倒霉游戏结束(“M”置为”X)</li><li>首次点击如果不是雷则探索周围八个方格(注意越界的和以判断过的不用再探索)</li><li>如果周围八个方格内有雷，则刷新点击的方格(将”E”置为雷的个数)</li><li>如果周围八个方格内没有雷，则刷新点击的方格(将”E”置为”B”)并且以同样方法点击周围八个方格(除去已点击过的和越界的)<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2>根据以上分析可以看出只需使用BFS遍历click即可。使用队列将需要遍历的节点存起来。定义一个数据结构square来保存方块信息。如果需要点击周围的方块，则将周围方块入队列（除去越界的和已遍历过的），点击完后出队列。遍历结束的条件是队列为空。<br>该方法是可行的，也是容易想到的。不过在雷盘较大时，队列占用空间较大，不能满足leetcode测试的内存限制。因此只能通过测试用例(28/54)。至于如何改进暂时没有想到（第一次写BFS的题，有点菜）。最近老是被时间和空间限制所困扰，自己以前写的程序里从来没有考虑这些东西，还是慢慢积累经验吧。  </li></ul><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>待改进…</p>]]></content>
      
      
      <categories>
          
          <category> 每天一道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法1：验证IP（leetcode-468）</title>
      <link href="/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/"/>
      <url>/2018/11/22/%E7%AE%97%E6%B3%951%EF%BC%9A%E9%AA%8C%E8%AF%81IP/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。<br><a id="more"></a></p><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p><strong>IPv4</strong>：地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；<br>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p><p><strong>IPv6</strong>：地址由8组16进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。<br>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。<br>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。 </p><p><strong>说明</strong>: 你可以认为给定的字符串里没有空格或者其他特殊字符。  </p><p><strong>示例 1</strong>:  </p><blockquote><p>输入: “172.16.254.1”</p><p>输出: “IPv4”</p></blockquote><p>解释: 这是一个有效的 IPv4 地址, 所以返回 “IPv4”。</p><p><strong>示例 2</strong>:  </p><blockquote><p>输入: “2001:0db8:85a3:0:0:8A2E:0370:7334”</p><p>输出: “IPv6”</p></blockquote><p>解释: 这是一个有效的 IPv6 地址, 所以返回 “IPv6”。</p><p><strong>示例 3</strong>:  </p><blockquote><p>输入: “256.256.256.256”</p><p>输出: “Neither”</p></blockquote><p>解释: 这个地址既不是 IPv4 也不是 IPv6 地址。</p><h1 id="我的解答"><a href="#我的解答" class="headerlink" title="我的解答"></a>我的解答</h1><h2 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIPv4</span><span class="params">(<span class="built_in">string</span> IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern&#123; <span class="string">"(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;"</span> &#125;;</span><br><span class="line"><span class="function">regex <span class="title">re</span><span class="params">(pattern)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(regex_match(IP, re))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIPv6</span><span class="params">(<span class="built_in">string</span> IP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> pattern&#123; <span class="string">"([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;"</span> &#125;;</span><br><span class="line"><span class="function">regex <span class="title">re</span><span class="params">(pattern)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (regex_match(IP, re))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(isIPv4(IP) ? <span class="string">"IPv4"</span>: (isIPv6(IP) ? <span class="string">"IPv6"</span>:<span class="string">"Neither"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>首先是方法的选择（如果不用正则表达式将会很麻烦）</li><li>正则表达式的书写</li><li>C++正则表达式的用法<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2></li></ul><ol><li><p>C++正则表达式介绍参见（<a href="https://blog.csdn.net/fengbingchun/article/details/54835571" target="_blank" rel="noopener">文章一</a>，<a href="https://www.cnblogs.com/ittinybird/p/4853532.html" target="_blank" rel="noopener">文章二</a>）</p></li><li><p>正则表达式的书写是一大难点需要多加练习加以积累。在本题中难点是ipv4的正则表达式书写。主要学会如何表示[0-255]的数。根据各部分的特征可以将这些数分为。</p><blockquote><ul><li>0-99:([1-9]?[0-9])</li><li>100-199:(1[0-9]{2})</li><li>200-249:(24[0-9])</li><li>250-255:(25[0-5])</li></ul></blockquote></li></ol><p>需要注意的有两点：一是对”.”的转义，二是或运算符的优先级最低，因此遇到多个或运算的时候每个部分都要加上括号避免出现二义性。<br>3.正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipv4:(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5]))(\.(([1-9]?[0-9])|(1[0-9]&#123;2&#125;)|(24[0-9])|(25[0-5])))&#123;3&#125;</span><br><span class="line">ipv6:([0-9a-fA-F])&#123;1,4&#125;(:([0-9a-fA-F])&#123;1,4&#125;)&#123;7&#125;</span><br></pre></td></tr></table></figure></p><hr><p>本题在掌握正则表达式后相对比较简单，对于正则表达式的书写还得再多加练习。然而正则虽好，编译器起来太耗时间了，该代码在leetcode上的执行用时60ms（击败0%的用户），emmmm….，好吧还是我太菜，不用正则的话能想到的改进就是c语言中的strchr()和strrchr()或者用类似python中的split</p><h2 id="来处理字符串。后面再测试测试。"><a href="#来处理字符串。后面再测试测试。" class="headerlink" title="()来处理字符串。后面再测试测试。  "></a>()来处理字符串。后面再测试测试。  </h2><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>待改进…</p>]]></content>
      
      
      <categories>
          
          <category> 每天一道算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WinSocket编程</title>
      <link href="/2018/11/11/WinSocket/"/>
      <url>/2018/11/11/WinSocket/</url>
      
        <content type="html"><![CDATA[<p>计算机网络实验：用Winsocket编写一个web服务器。<br>要求：能够处理响应报文，发送各种类型的文件，多线程实现。代码见我的github：<a href="https://github.com/loveshrimp/web-server" target="_blank" rel="noopener">web_server</a><br><a id="more"></a></p><h1 id="Winsocket介绍"><a href="#Winsocket介绍" class="headerlink" title="Winsocket介绍"></a>Winsocket介绍</h1><h2 id="什么是Socket编程"><a href="#什么是Socket编程" class="headerlink" title="什么是Socket编程"></a>什么是Socket编程</h2><p>由于老师上课的时候从来没有具体的讲过Socket编程，因此，什么是Socket编程便成了我的第一个问题。<br>通俗的来讲socket编程就是为了来写可以联网的应用程序的。像我们平常使用的qq，它其实是一个程序，程序是静态的概念，就是一段代码。当我们双击qq图标时。操作系统将这段代码加载到内存中并分配相应的内存空间，此时便产生了一个进程。当我们再次双击图标时，程序又会再次加载一遍生成另外一个进程。Socket就是为了实现不同电脑（主机）上的不同进程之间的通信问题的一个编程接口。它是一个接口（称为套接字）你只需要将数据扔给他，他就会将数据传送到相互通信的另一个套接字中，而不需要关注数据是如何在运输层和链路层运输的。当有数据传输给你时，你只需要从socket中去取数据即可。</p><h2 id="winSocket介绍"><a href="#winSocket介绍" class="headerlink" title="winSocket介绍"></a>winSocket介绍</h2><p>WinSocket是windows系统下的Socket编程api。<br>Winsock 是通过动态链接库的方式提供给软件开发者，而且从Windows 95以后已经被集成到了Windows操作系统中。Winsock主要经历了2个版本：Winsock 1.1和Winsock 2.0。Winsock 2.0是Winsock 1.1的扩展，它向下完全兼容。Winsock同时包括了16位和32位的编程接口，16位的Windows Socket 2应用程序使用的动态链接库是WINSOCK.DLL，而32位的Windows Socket应用程序使用WSOCK32.DLL（Winsock 1.1版）和WS2_32.DLL（Winsock 2.0版）。另外，使用Winsock API时要包含头文件winsock.h（Winsock 1.1版）或winsock2.h（Winsock 2.0版）。  </p><hr><h1 id="Web-server实验"><a href="#Web-server实验" class="headerlink" title="Web_server实验"></a>Web_server实验</h1><h2 id="Socket编程的一般步骤"><a href="#Socket编程的一般步骤" class="headerlink" title="Socket编程的一般步骤"></a>Socket编程的一般步骤</h2><pre class="mermaid">graph TDA(Init);B(Creat Listen_socket);C(Bind);D(Listen);E(Creat Connect_socket);F(Connection);G(Close Connect_socket);A-->BB-->CC-->DD-- if_request ---EE-->FF-->GG-->Quit</pre><hr><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinSocket </tag>
            
            <tag> 网络通信 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
